set cut_paste_input [stack 0]
version 9.0 v1
push 0
push $cut_paste_input
Group {
 inputs 2
 name CardToTrack
 tile_color 0x5236ff
 gl_color 0xff0000ff
 note_font "Bitstream Vera Sans Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold"
 note_font_size 14
 note_font_color 0xff
 addUserKnob {20 User l CardToTrack}
 addUserKnob {26 extras l "" t "here you can choose the way you would like find your position\n\n1 I have a Camera and great Matchmove\n   means you have only a tracked Camera - you will have to go normal way in finding position\n\n2  I have a Camera and Geometry\n   see little input called \"Extra\"? this is your new friend, if you have by any chance a geometry of the Scene - can be a model, lidar scan or just a bunch Nuke objects, connect it to the \"Extra\" input and press \"Set\" button, congrats you found your 3D position and ready sdjust your perspective(no need to bother with \"Z\" and \"Happy\" button\n\n3  I have a Camera and Wpos pass\n    if your nice 3D Artist rendered for you a Wpos pass, connect it to the \"Extra\" input and press \"Set\" button, congrats you found your 3D position and ready sdjust your perspective(no need to bother with \"Z\" and \"Happy\" button\n\n4  I have a Camera and Card\n    Let say you have animated Card and you want to translate it's position to Screen space, connect the Card to the .... guess what and press \"GO\" button\n    DONE!!!" +STARTLINE T "I have a Camera and"}
 addUserKnob {4 extraStuff l "" t "here you can choose the way you would like find your position\n\n1 I have a Camera and great Matchmove\n   means you have only a tracked Camera - you will have to go normal way in finding position\n\n2  I have a Camera and Geometry\n   see little input called \"Extra\"? this is your new friend, if you have by any chance a geometry of the Scene - can be a model, lidar scan or just a bunch Nuke objects, connect it to the \"Extra\" input and press \"Set\" button, congrats you found your 3D position and ready sdjust your perspective(no need to bother with \"Z\" and \"Happy\" button\n\n3  I have a Camera and Wpos pass\n    if your nice 3D Artist rendered for you a Wpos pass, connect it to the \"Extra\" input and press \"Set\" button, congrats you found your 3D position and ready sdjust your perspective(no need to bother with \"Z\" and \"Happy\" button\n\n4  I have a Camera and Card\n    Let say you have animated Card and you want to translate it's position to Screen space, connect the Card to the .... guess what and press \"GO\" button\n    DONE!!!" -STARTLINE M {"great match move!!!" Geometry "Wpos pass" Card "" "" ""}}
 addUserKnob {3 extraHelper l INVISIBLE -STARTLINE +INVISIBLE}
 extraHelper {{"\[numvalue extraStuff]"}}
 addUserKnob {3 scene l "      scene size" t "the tool does not know how big your scene is, if after adjusting \"Z\" slider you see that the card you generating is too big or too small - adjust the scene size.\n\nyou not going to see something changing till you will press \"Set\" button again\n\nif you do happy you can leave this knob alone there will be no need to touch it again\n\njust remember the value so you will be able to enter it when you will be work on the other shots from the same sequence\n\ncheers!" -STARTLINE}
 scene 10
 addUserKnob {26 ""}
 addUserKnob {26 ds l <b>1. t "first step in finding desired position.\n\nplease find some feature on the screen, feature you can see on the other frames as well.\nnot position the picker on this feature and press \"Set\" button\n\nthe reference frame is set, yo should see now the grid centering on the \"picker\"\n\nthere is a chance that \"grid\" will be very small or very big depends on the size of your scene, feel free to adjust it's size with the u_scale knob.\n\nnow you ready for the next step" T "Set reference frame."}
 addUserKnob {22 REF l Set t "first step in finding desired position.\n\nplease find some feature on the screen, feature you can see on the other frames as well.\nnot position the picker on this feature and press \"Set\" button\n\nthe reference frame is set, yo should see now the grid centering on the \"picker\"\n\nthere is a chance that \"grid\" will be very small or very big depends on the size of your scene, feel free to adjust it's size with the u_scale knob.\n\nnow you ready for the next step" T "n = nuke.thisNode()\nnuke.toNode(\"Switch1\")\['disable'].setValue(0)\nnuke.toNode(\"StabFrameHold\")\['first_frame'].setValue(n\['refFrame'].value())\n\nif n\['S'].value() == 1:\n\tn\['Stabilize'].execute()\ncam=n.input(1)\nclas = cam.Class()\nss=n\['scene'].value()\nif \"Camera\" in clas:\n\tnuke.toNode(\"NoOp1\")\['pick'].execute()\n\tn\['refFrame'].setValue(nuke.frame())\n\tnuke.toNode(\"Switch\")\['which'].setValue(0)\n\tr=nuke.toNode(\"Perspective\")\n\tr.setSelected(False)\n\tr.hideControlPanel()\n\tr\['rotate'].setValue(0)\n\tr\['translate'].setValue(0)\n\tr\['scaling'].setValue(1)\n\tr\['uniform_scale'].setValue(ss)\n\nelse:\n\tnuke.message(\"please connect Camera node straight to the node, do not use nodes in between, thank you for your collaboration\")\n\nif n\['extraHelper'].value()==1 or n\['extraHelper'].value()==2:\n    n\['Adjust'].execute()\n    n\['group'].setFlag(1)\n    n\[\"Zfind\"].setValue(0)\nelse:\n    n\['group'].clearFlag(1)" +STARTLINE}
 addUserKnob {22 Stabilize -STARTLINE T "\n\n\nnode = nuke.thisNode() \nt = node\['S']\n\nif t.value() == 0:\n   nuke.thisKnob().setLabel('<font color=\"Red\"><b>Stabilized')\n   t.setValue(1)\n   nuke.toNode(\"StabFrameHold\")\['disable'].setValue(0)\n   nuke.toNode(\"StabFrameHold\")\['first_frame'].setValue(node\['refFrame'].value())\n   nuke.toNode(\"StabSwitch\")\['disable'].setValue(0)\nelse:\n   nuke.thisKnob().setLabel('Stabilize')\n   t.setValue(0)\n   nuke.toNode(\"StabFrameHold\")\['disable'].setValue(1)\n   nuke.toNode(\"StabSwitch\")\['disable'].setValue(1)"}
 addUserKnob {6 S l INVISIBLE -STARTLINE +INVISIBLE}
 addUserKnob {3 refFrame l "   reference frame:" -STARTLINE}
 refFrame 1053
 addUserKnob {41 picker l "     " -STARTLINE T NoOp1.picker}
 addUserKnob {41 hue_rotation l "hue grid" T HueShift1.hue_rotation}
 addUserKnob {7 op l "     opacity grid" -STARTLINE}
 op 1
 addUserKnob {26 ""}
 addUserKnob {20 group l "" +STARTLINE n 1}
 addUserKnob {26 d l "<b>2. " t "Second step help us to find exact position in 3d space\n\nstart advance few frames, you should see that a grid is not fixed anymore to your reference feature, from the moment you noticing it is happening adjust \"Z\" knob to bring the \"grid\" back to the place it was. already after first adjustment you will see that grid is sticking well to the feature. Now you can go to some other frame and refine the position again if needed\n\nTipp:\nit is possible that already after one or two frames of advancement your grid will disappear it can happen because of the size of your scene. just play with \"Z\" slider till you will bring the \"grid\" back to the screen. it is possible that you will have to go to negative values as well." T "go to some other frame and adjust Z."}
 addUserKnob {7 Zfind l Z t "Second step help us to find exact position in 3d space\n\nstart advance few frames, you should see that a grid is not fixed anymore to your reference feature, from the moment you noticing it is happening adjust \"Z\" knob to bring the \"grid\" back to the place it was. already after first adjustment you will see that grid is sticking well to the feature. Now you can go to some other frame and refine the position again if needed.\nonce you happy with the result\npress \"Happy\" button!!!\n\nTipp:\nit is possible that already after one or two frames of advancement your grid will disappear it can happen because of the size of your scene. just play with \"Z\" slider till you will bring the \"grid\" back to the screen. it is possible that you will have to go to negative values as well." R -100 100}
 Zfind 10
 addUserKnob {26 ""}
 addUserKnob {26 s l <b>3. t "this will create an axis in exact 3D position you found\nplease adjust (if needed)\nrotation of the card to match exact perspective you want\n\nTipp :\nadjusting \"scale\" and \"u_scale\":\nbe carefull when scaling up the card!!! from the moment one of the corners of the \"grid\" is passing the origin of the Camera the calculation will fail. So as a good practice leave your \"grid\" not too big it will not matter for final calculation since it still will lay on the same plane.\n\n" T "Happy with Z? Press \"Happy\" button and adjust perspective."}
 addUserKnob {22 Adjust l Happy!!! t "this will create an axis in exact 3D position you found\nplease adjust (if needed)\nrotation of the card to match exact perspective you want\n\nTipp :\nadjusting \"scale\" and \"u_scale\":\nbe carefull when scaling up the card!!! from the moment one of the corners of the \"grid\" is passing the origin of the Camera the calculation will fail. So as a good practice leave your \"grid\" not too big it will not matter for final calculation since it still will lay on the same plane.\n\n" T "def consolidateAnimatedNodeTransforms():\n    # This is based on Ivan B's consolidateNodeTransforms().\n    # Added support for animated Axis/Camera nodes. Also, if it's\n    # a Camera being concatenated, then projection settings get copied.\n    # -Ean C 24/Feb/2011\n    import math\n    import nuke\n    axisNode = nuke.toNode('Z_finder')\n    m = nuke.math.Matrix4()\n\n    nuke.toNode(\"Switch\")\['which'].setValue(1)\n    n = nuke.toNode('Perspective')\n    n\['scaling'].setExpression('curve')\n    n\['rotate'].setExpression('curve')\n    n\['translate'].setExpression('curve')\n\n    first_frame_v = nuke.root()\['first_frame'].value()\n    last_frame_v = nuke.root()\['last_frame'].value()\n\n    scale_anim = n\['scaling'].animations()\n    rotate_anim = n\['rotate'].animations()\n    translate_anim = n\['translate'].animations()\n\n    for i in range(int(first_frame_v), int(last_frame_v+1)):\n\n        k = axisNode\['world_matrix']\n        k_time_aware = axisNode\['world_matrix'].getValueAt(i)\n\n\n        for y in range(k.height()):\n            for x in range(k.width()):\n                m\[x+(y*k.width())] = k_time_aware\[y + k.width()*x]\n\n\n            transM =nuke.math.Matrix4(m)\n            transM.translationOnly()\n            rotM = nuke.math.Matrix4(m)\n            rotM.rotationOnly()\n            scaleM = nuke.math.Matrix4(m)\n            scaleM.scaleOnly()\n\n            scale = (scaleM.xAxis().x, scaleM.yAxis().y, scaleM.zAxis().z)\n\n            rot = rotM.rotationsZXY()\n            rotDegrees = ( math.degrees(rot\[0]), math.degrees(rot\[1]), math.degrees(rot\[2]) )\n\n\n            trans = (transM\[12], transM\[13], transM\[14])\n\n            for s in range(3):\n                scale_anim\[s].setKey(i, scale\[s])\n                rotate_anim\[s].setKey(i, rotDegrees\[s])\n                translate_anim\[s].setKey(i, trans\[s])\n    n\['translate'].clearAnimated()\n    n\['rotate'].clearAnimated()\n    n\['scaling'].clearAnimated()\n    n\['uniform_scale'].setValue(nuke.toNode(\"Card1\")\['uniform_scale'].value())\n    #nuke.show((n), True)\n    n.setSelected(True)\n    r=nuke.toNode(\"look_at_Axis\")\n    r.setSelected(False)\n    r.hideControlPanel()\t\t\t\nconsolidateAnimatedNodeTransforms()\n\na=nuke.thisNode()\nif a\['S'].value() == 1:\n    a\['Stabilize'].execute()" +STARTLINE}
 addUserKnob {20 endGroup n -1}
 addUserKnob {41 translate T Perspective.translate}
 addUserKnob {41 rotate l "rotate    " T Perspective.rotate}
 addUserKnob {41 scaling l "scale     " T Perspective.scaling}
 addUserKnob {41 uniform_scale l "u_scale " T Perspective.uniform_scale}
 addUserKnob {26 ""}
 addUserKnob {26 r l <b>4. t "this little fellow will create for you three nodes\n\n1. CProject - basically it is a cornerPin node with steroids it allowes to you very easy set Reference point for your \"projection\", stabilize, crop. all in one\n2. CornerPin with a transformation baked in the \"matrix\" knob - usually i am using it to copy to GridWarp or SplineWarp\n3. Roto - the node i am using the most.\nthe transformation is baked into the root matrix.\nso just pick the frame create the rotoshape and enjoy!" T "Time to create our Nodes!"}
 addUserKnob {22 C2T l <b>-----------------------GO!----------------------- t "this little fellow will create for you three nodes\n\n1. CProject - basically it is a cornerPin node with steroids it allowes to you very easy set Reference point for your \"projection\", stabilize, crop. all in one\n2. CornerPin with a transformation baked in the \"matrix\" knob - usually i am using it to copy to GridWarp or SplineWarp\n3. Roto - the node i am using the most.\nthe transformation is baked into the root matrix.\nso just pick the frame create the rotoshape and enjoy!" T "\n\na=nuke.thisNode()\n\nif a\['S'].value() == 1:\n    a\['Stabilize'].execute()\n\na.begin()\nx=int(a\['xpos'].value())\ny=int(a\['ypos'].value())\np = nuke.toNode(\"Perspective\")\nt=p\['translate'].value()\nr=p\['rotate'].value()\ns=p\['scaling'].value()\nus=p\['uniform_scale'].value()\nnuke.toNode(\"Switch\")\['which'].setValue(1)\na.end()\n\n\nfor node in nuke.allNodes():\n    node.setSelected(False)\na.input(1).setSelected(True)\na.input(0).setSelected(True)\n\nif a\['extraHelper'].value()==3:\n    a.input(2).setSelected(True)\nelse:\n    n = nuke.nodes.Card2()\n    n.setXYpos(x,y+100)\n    n\['translate'].setValue(t)\n    n\['rotate'].setValue(r)\n    n\['scaling'].setValue(s)\n    n\['uniform_scale'].setValue(us)\n    n.setSelected(True)\n\nwith nuke.Root():\n    #C2T new\n    import thread, threading, time, nuke, math, nukescripts\n\n    def execRC(first,last):\n        runMe = True\n        while runMe == True:\n            nuke.execute('r1',first,last)  \n            nuke.execute('r2',first,last) \n            nuke.execute('r3',first,last) \n            nuke.execute('r4',first,last) \n            stop_event.set()\n            runMe = False\n            print 'reconcile done'\n            break\n\n    def getCamera():\n        cam = a.input(1)\n        return cam\n\n\n\n    def BGdetect():\n        for n in nuke.selectedNodes():\n            #if 'format' in n.knobs():\n            if 'xform_order' not in n.knobs():\n                Name = n.name()\n                Width = n.width()\n                Height = n.height()\n                Aspect = n.pixelAspect()\n                form = str(Width)+\" \"+str(Height)+\" \"+str(Aspect)\n                print 'format selected:'+\" \"+form\n                \n                bg = nuke.nodes.Constant(postage_stamp = False)\n                bg\['format'].setValue(nuke.addFormat(form))\n                return bg\n        #no format found ...\n        \n        #bg = nuke.createNode('Constant')\n        #bg = nuke.nodes.Constant(postage_stamp = False)\n        #return bg\n            \n    def C2T(dialog):\n\n        # classes\n\n        cardClasses = \['Card', 'Card2']\n\n        #card\n        card = None\n        for n in nuke.selectedNodes():\n            if n.Class() in cardClasses:\n                card = n\n                break\n        if card == None:\n            nuke.message('no card selected?')\n            return\n\n\n            \n            \n        # initialize tool values for auto-creation\n        label = card\['label'].value()\n        ref = int(nuke.frame())\n        first = int(nuke.Root().knob('first_frame').getValue())\n        last = int(nuke.Root().knob('last_frame').getValue())\n        bg = BGdetect() \n        cam = getCamera()\n        rootAspect = nuke.Root()\['format'].value().pixelAspect()\n        x = card.xpos() \n        y = card.ypos()\n        \n        bg.setXYpos(x,y+50)\n        \n        if dialog == True:\n            # ask for tool values\n            \n            # all cams\n            \n\n            \n            #bg, info only. will be determined by selected node - if any ..\n\n            #formatPrint = form\n\n            #panel\n            panel = nuke.Panel(\"C2T\")\n            panel.addSingleLineInput(\"label:\", card\['label'].value())\n            panel.addSingleLineInput(\"range:\", str(first)+\"-\"+str(last))\n            panel.addSingleLineInput(\"ref frame:\", str(ref))\n            #panel.addEnumerationPulldown(\"camera:\", camListPrint)\n            #panel.addSingleLineInput(\"format:\", formatPrint)\n            if label == '':\n                panel.addBooleanCheckBox('reverse label', True)\n                \n            #panel.show()\n            \n            if panel.show():\n                first = int(panel.value(\"range:\").split(\"-\")\[0])\n                last = int(panel.value(\"range:\").split(\"-\")\[1])\n                ref = int(panel.value(\"ref frame:\"))\n                #cam = nuke.toNode(panel.value(\"camera:\"))\n                label = panel.value(\"label:\")\n                # reverse label\n                if panel.value(\"reverse label\") == True:\n                    card\['label'].setValue(panel.value(\"label:\"))\n            else:\n                nuke.message('canceled')\n                nuke.delete(bg) # clean the mess up\n                return\n        else:\n            print 'no dialog, use auto-created input values'\n        \n        # labels are usefull!!\n        if label == '':\n            panel = nuke.Panel(\"C2T label\")\n            panel.addSingleLineInput(\"label:\", '')\n            panel.addBooleanCheckBox('reverse label', True)\n            if panel.show():\n                label = panel.value(\"label:\")\n                if panel.value(\"reverse label\") == True:\n                    card\['label'].setValue(panel.value(\"label:\"))\n                else:\n                    nuke.message('no label - no roto!')\n                    nuke.delete(bg) # clean the mess up\n                    return\n            else:\n                return\n        print '########'\n        print 'first', first\n        print 'last', last\n        print 'ref', ref\n        #print 'bg', form\n        print 'cam', cam.name()\n        print 'card', card.name()\n        print 'label', label\n        print '########' \n        \n        # create master axis and corner slaves\n        \n        aM = nuke.nodes.Axis2(name = 'aM', xform_order = 3, xpos = x, ypos = y+50)\n        uscale = card\['uniform_scale'].value()\n        scalex = card\['scaling'].value(0)\n        scaley = card\['scaling'].value(1)\n        \n        if card\['translate'].isAnimated() is True:\n            aM\['translate'].copyAnimations(card\['translate'].animations())\n        else:\n            aM\['translate'].setValue(card\['translate'].value())\n        \n        if card\['rotate'].isAnimated() is True:\n            aM\['rotate'].copyAnimations(card\['rotate'].animations())\n        else:\n            aM\['rotate'].setValue(card\['rotate'].value())\n            \n            \n        # slaves\n        a1 = nuke.nodes.Axis2(name = 'a1', xform_order = 1, xpos = x, ypos = y+50)\n        a2 = nuke.nodes.Axis2(name = 'a2', xform_order = 1, xpos = x, ypos = y+50)\n        a3 = nuke.nodes.Axis2(name = 'a3', xform_order = 1, xpos = x, ypos = y+50)\n        a4 = nuke.nodes.Axis2(name = 'a4', xform_order = 1, xpos = x, ypos = y+50)\n        \n        a1\['translate'].setValue(\[-0.5*uscale*scalex,rootAspect*-0.5*uscale*scaley,0])\n        a2\['translate'].setValue(\[0.5*uscale*scalex,rootAspect*-0.5*uscale*scaley,0])\n        a3\['translate'].setValue(\[0.5*uscale*scalex,rootAspect*0.5*uscale*scaley,0])\n        a4\['translate'].setValue(\[-0.5*uscale*scalex,rootAspect*0.5*uscale*scaley,0])\n        \n        aL = \[a1,a2,a3,a4]\n        \n        for a in aL:\n            a.setInput(0,aM)\n\n        # reconcile\n        r1 = nuke.nodes.Reconcile3D(name = 'r1', xpos = x, ypos = y+50)\n        r2 = nuke.nodes.Reconcile3D(name = 'r2', xpos = x, ypos = y+50)\n        r3 = nuke.nodes.Reconcile3D(name = 'r3', xpos = x, ypos = y+50)\n        r4 = nuke.nodes.Reconcile3D(name = 'r4', xpos = x, ypos = y+50)\n        \n        rL = \[r1,r2,r3,r4]\n        \n        for r in rL:\n            r.setInput(2,aL\[rL.index(r)])\n            r.setInput(1,cam)\n            r.setInput(0,bg)\n            \n        # run with threading\n        global stop_event \n        stop_event = threading.Event()\n        threading.Thread(target=execRC, kwargs=dict(first=first,last=last)).start() \n        while not stop_event.is_set():\n            time.sleep(0.1)\n\n        problem = 0\n        import math\n        timeline = \[\"beginning\",\"end\"]#######looping to fix stuff before and after ref frame\n        for side in timeline:##########################################################################################################: Fixing the curve###############################\n            if side == \"beginning\":\n                firstT = first\n                lastT = ref\n            if side == \"end\":\n                firstT = ref\n                lastT = last\n\n            for one in rL:########fixing stuff\n                curveXUp = 0\n                curveXDown = 0\n                curveYUp = 0\n                curveYDown = 0\n                fuckedFrames = \[]\n                k = one\[\"output\"]\n                valsx = \[];valSortx =\[]\n                valsy = \[];valSorty =\[]\n                for i in range(firstT,lastT+1):\n                    valsx.append(k.valueAt(i,0))\n                    valSortx.append(k.valueAt(i,0))\n                    valsy.append(k.valueAt(i,1))\n                    valSorty.append(k.valueAt(i,1))\n                valSortx.sort()\n                valSorty.sort()\n                minX = valSortx\[0]\n                maxX = valSortx\[-1]\n                minY = valSorty\[0]\n                maxY = valSorty\[-1]\n                if math.fabs(valsx.index(maxX)-valsx.index(minX)) == 1:\n                    problem = 1\n        if problem == 1:\n            if nuke.ask(\"Perspective problem detected! would you like to fix it? \\n your card did pass the Camera center, this causes the track to break, i will try to fix the problem. if my fix will not succeed you should use a bit smaller card so corners of the card will not cross the camera so fast.\"):\n                problem = 0\n                import math\n                timeline = \[\"beginning\",\"end\"]#######looping to fix stuff before and after ref frame\n                lastB = last\n                firstB = first\n                for side in timeline:##########################################################################################################: Fixing the curve###############################\n                    if side == \"beginning\":\n                        last = ref\n                    if side == \"end\":\n                        first = ref\n                        last = lastB\n\n                    for one in rL:########fixing stuff\n                        curveXUp = 0\n                        curveXDown = 0\n                        curveYUp = 0\n                        curveYDown = 0\n                        fuckedFrames = \[]\n                        k = one\[\"output\"]\n                        valsx = \[];valSortx =\[]\n                        valsy = \[];valSorty =\[]\n                        for i in range(first,last+1):\n                            valsx.append(k.valueAt(i,0))\n                            valSortx.append(k.valueAt(i,0))\n                            valsy.append(k.valueAt(i,1))\n                            valSorty.append(k.valueAt(i,1))\n                        valSortx.sort()\n                        valSorty.sort()\n                        minX = valSortx\[0]\n                        maxX = valSortx\[-1]\n                        minY = valSorty\[0]\n                        maxY = valSorty\[-1]\n                        if math.fabs(valsx.index(maxX)-valsx.index(minX)) == 1:\n                            problem = 1\n                            #print \"minX \",minX,\"maxX\",maxX,\"minY\",minY,\"maxY \",maxY\n                            #message = \"your card did pass the Camera center, this causes the track to break, i tried to fix the problem. if my fix did not succeed you should use a bit smaller card so corners of the card will not cross the camera so fast.\"\n                            if valsx.index(maxX)-valsx.index(minX) < 0:    ###############checking if the curve going up or down\n                                curveXUp = 1\n                            else:\n                                curveXDown = 1\n                            if valsy.index(maxY)-valsy.index(minY) < 0:    ###############checking if the curve going up or down\n                                curveYUp = 1\n                            else:\n                                curveYDown = 1\n                            if valsx.index(maxX)+first > ref:                                  ##### kill tail X\n                                if curveXDown == 1: ##### curve X is going down####################################################################################FIXEDforEnd\n                                    lastGoodX= k.valueAt(valsx.index(minX)+first,0)\n                                    prelastGoodX= k.valueAt(valsx.index(minX)+first-1,0)\n                                    diffX= abs(lastGoodX) - abs(prelastGoodX)\n                                    offsetX = abs(lastGoodX)+maxX+diffX*2\n                                    for i in range(valsx.index(maxX)+first,last+1):\n                                        val = k.valueAt(i)\[0]\n                                        k.setValueAt(val-offsetX,i,0)\n                                if curveXUp == 1: ##### curve X is going up####################################################################################FIXEDforEnd\n                                    print \"up!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\"\n                                    lastGoodX = k.valueAt(valsx.index(maxX)+first,0) \n                                    prelastGoodX= k.valueAt(valsx.index(maxX)+first-1,0) \n                                    diffX= abs(lastGoodX)- abs(prelastGoodX)\n                                    offsetX= maxX+abs(minX)+diffX*2\n                                    for i in range(valsx.index(minX)+first,last+1):\n                                        val = k.valueAt(i)\[0]\n                                        k.setValueAt(val+offsetX,i,0)\n                            if valsy.index(maxY)+first > ref:                                  ##### kill tail Y\n                                if curveYDown == 1: ##### curve Y is going down#####################################################################################FIXEDforEnd\n                                    lastGoodY= k.valueAt(valsy.index(minY)+first,1)\n                                    prelastGoodY= k.valueAt(valsy.index(minY)+first-1,1)\n                                    diffY= abs(lastGoodY) - abs(prelastGoodY) \n                                    offsetY = abs(lastGoodY)+maxY+diffY*2\n                                    for i in range(valsy.index(maxY)+first,last+1):\n                                        val = k.valueAt(i)\[1]\n                                        k.setValueAt(val-offsetY,i,1)\n                                if curveYUp == 1: ##### curve Y is going up####################################################################################FIXEDforEnd\n                                    lastGoodY = k.valueAt(valsy.index(maxY)+first,1) \n                                    prelastGoodY= k.valueAt(valsy.index(maxY)+first-1,1) \n                                    diffY=abs(lastGoodY) - abs(prelastGoodY) \n                                    offsetY= maxY+abs(minY)+diffY*2\n                                    for i in range(valsy.index(minY)+first,last+1):\n                                        val = k.valueAt(i)\[1]\n                                        k.setValueAt(val+offsetY,i,1)\n                            if valsx.index(maxX)+first < ref:                                  ##### kill head X-------------------------------------------------------------------------------------\n                                print \"kill X head\"\n                                if curveXDown == 1: ##### curve X is going down#####################################################################################FIXEDforBeginning\n                                    firstGoodX= k.valueAt(valsx.index(maxX)+first,0)\n                                    prefirstGoodX= k.valueAt(valsx.index(maxX)+first+1,0)\n                                    diffX= abs(firstGoodX) - abs(prefirstGoodX) \n                                    offsetX = abs(firstGoodX)+abs(minX)+diffX*2\n                                    for i in range(first,valsx.index(maxX)+first):\n                                        val = k.valueAt(i)\[0]\n                                        k.setValueAt(val+offsetX,i,0)\n                                if curveXUp == 1: ##### curve X is going up#####################################################################################FIXEDforBeginning\n                                    firstGoodX = k.valueAt(valsx.index(minX)+first,0) \n                                    prefirstGoodX= k.valueAt(valsx.index(minX)+first+1,0) \n                                    diffX= abs(firstGoodX) - abs(prefirstGoodX) \n                                    offsetX= abs(firstGoodX)+maxX+diffX*2\n                                    for i in range(first,valsx.index(minX)+first):\n                                        val = k.valueAt(i)\[0]\n                                        k.setValueAt(val-offsetX,i,0)\n                            if valsy.index(maxY)+first < ref:                                  ##### kill head Y\n                                if curveYDown == 1: ##### curve Y is going down#####################################################################################FIXEDforBeginning\n                                    firstGoodY = k.valueAt(valsy.index(maxY)+first,1)\n                                    prefirstGoodY =  k.valueAt(valsy.index(maxY)+first+1,1)\n                                    diffY =  abs(firstGoodY) - abs(prefirstGoodY)\n                                    offsetY =  abs(firstGoodY)+abs(minY)+diffY*2\n                                    for i in range(first,valsy.index(maxY)+first):\n                                        val = k.valueAt(i)\[1]\n                                        k.setValueAt(val+offsetY,i,1)\n                                    print  \"y down\"\n                                if curveYUp == 1: ##### curve Y is going up#####################################################################################FIXEDforBeginning\n                                    firstGoodY = k.valueAt(valsy.index(minY)+first,1)\n                                    prefirstGoodY = k.valueAt(valsy.index(minY)+first+1,1)\n                                    diffY = abs(firstGoodY) - abs(prefirstGoodY)\n                                    offsetY = abs(firstGoodY)+maxY+diffY*2\n                                    for i in range(first,valsy.index(minY)+first):\n                                        val = k.valueAt(i)\[1]\n                                        k.setValueAt(val-offsetY,i,1)\n\n                last = lastB\n                first = firstB\n            else:\n                pass\n\n        # corner pin normal\n        try :\n            cp = nuke.nodes.CProject(xpos = x+110, ypos = y)\n            cp\['camera'].setValue(cam.name())\n            cp\['translate'].setValue(card\['translate'].value())\n            cp\['rotation'].setValue(card\['rotate'].value())\n            cp\['element'].setValue(label)\n            cp.setName(cp\['name'].value().replace('CProject','CP')+\"_\"+label)\n            cp\['refFrame'].setValue(str(ref))\n        except:\n            cp = nuke.nodes.CornerPin2D(label = label +' ('+str(ref)+')', xpos = x+110, ypos = y)  \n        cp\['to1'].copyAnimations(r1\['output'].animations())\n        cp\['to2'].copyAnimations(r2\['output'].animations())\n        cp\['to3'].copyAnimations(r3\['output'].animations())\n        cp\['to4'].copyAnimations(r4\['output'].animations())\n        cp\['from1'].setValue(r1\['output'].getValueAt(ref))\n        cp\['from2'].setValue(r2\['output'].getValueAt(ref))\n        cp\['from3'].setValue(r3\['output'].getValueAt(ref))\n        cp\['from4'].setValue(r4\['output'].getValueAt(ref))\n\n\n        # corner pin matrix & roto \n        cpm = nuke.nodes.CornerPin2D(label = label+' matrix ('+str(ref)+')', xpos = x+220, ypos = y)   \n        roto = nuke.nodes.Roto( xpos = x+330, ypos = y) \n        roto.setName(roto\['name'].value().replace('Roto','R')+\"_\"+label)\n        nuke.show(roto)\n        \n        roto_transform = roto\['curves'].rootLayer.getTransform() # transform of root layer in roto\n        cpm\['transform_matrix'].setAnimated()\n        projectionMatrixTo = nuke.math.Matrix4()\n        projectionMatrixFrom = nuke.math.Matrix4()\n\n        frame = first\n        while frame<last+1:\n\n            to1x = cp\['to1'].valueAt(frame)\[0]\n            to1y = cp\['to1'].valueAt(frame)\[1]\n            to2x = cp\['to2'].valueAt(frame)\[0]\n            to2y = cp\['to2'].valueAt(frame)\[1]\n            to3x = cp\['to3'].valueAt(frame)\[0]\n            to3y = cp\['to3'].valueAt(frame)\[1]\n            to4x = cp\['to4'].valueAt(frame)\[0]\n            to4y = cp\['to4'].valueAt(frame)\[1]\n\n            from1x = cp\['from1'].valueAt(frame)\[0]\n            from1y = cp\['from1'].valueAt(frame)\[1]\n            from2x = cp\['from2'].valueAt(frame)\[0]\n            from2y = cp\['from2'].valueAt(frame)\[1]\n            from3x = cp\['from3'].valueAt(frame)\[0]\n            from3y = cp\['from3'].valueAt(frame)\[1]\n            from4x = cp\['from4'].valueAt(frame)\[0]\n            from4y = cp\['from4'].valueAt(frame)\[1]\n        \n            projectionMatrixTo.mapUnitSquareToQuad(to1x,to1y,to2x,to2y,to3x,to3y,to4x,to4y)\n            projectionMatrixFrom.mapUnitSquareToQuad(from1x,from1y,from2x,from2y,from3x,from3y,from4x,from4y)\n            theCornerpinAsMatrix = projectionMatrixTo*projectionMatrixFrom.inverse()\n            theCornerpinAsMatrix.transpose()\n\n            for i in range(0,16):\n                cpm\['transform_matrix'].setValueAt(theCornerpinAsMatrix\[i],frame,i)\n                \n            for i in range(0,16):\n                roto_transform.getExtraMatrixAnimCurve(0,i).addKey(frame,cpm\['transform_matrix'].getValueAt(frame,i))  \n                \n            frame = frame + 1\n\n        roto\['curves'].changed()\n\n        # check for turnover\n        k = cp\['to1']\n        vals = \[]\n        valSort =\[]\n        for i in range(first,last+1):\n            vals.append(k.valueAt(i,0))\n            valSort.append(k.valueAt(i,0))\n        valSort.sort()\n        min = valSort\[0]\n        max = valSort\[-1]\n        # warning = ''\n        # if math.fabs(vals.index(max)-vals.index(min)) == 1:\n        #     warning = 'Warning: perspective problem detected'\n\n\n        #clean up\n        rmL = \[r1,r2,r3,r4,a1,a2,a3,a4,aM]\n        for i in rmL:\n            nuke.delete(i)\n        nuke.delete(bg)\n        \n        if dialog == False:\n            roto.setXYpos(x+100,y)\n            #remove all non roto nodes\n            nuke.delete(cp)\n            nuke.delete(cpm)\n            \n            \n        # show warning if any\n        # if warning != '':\n        #     nuke.message(warning)\n\n        print 'C2T done.!!!!!'\n        # if problem == 1:\n        #     nuke.message(message)\n\n    C2T(True)\n\n\n\n\n" +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 credit l " &copy;" T "Helge Stang & Alexey Kuchinski"}
 addUserKnob {20 help_1 l Help}
 addUserKnob {26 hhelp l "" +STARTLINE T "---------------------------------------------------\nStep 1\n\nplease find some feature on the screen, feature you can see on the other frames as well.\nnow position the picker on this feature and press \"Set\" button\n\nthe reference frame is set, yo should see now the grid centering on the \"picker\"\n\nthere is a chance that \"grid\" will be very small or very big depends on the size of your scene, feel free to adjust it's size with the u_scale knob.\n\nnow you ready for the next step\n\n---------------------------------------------------\nStep 2\n\nLet's find exact position in 3d space\n\nstart advance few frames, you should see that a grid is not fixed anymore to your reference feature, from the moment you noticing it is happening adjust \"Z\" knob to bring the \"grid\" back to the place it was. already after first adjustment you will see that grid is sticking well to the feature. Now you can go to some other frame and refine the position again if needed\n\nTipp:\nit is possible that already after one or two frames of advancement your grid will disappear it can happen because of the size of your scene. just play with \"Z\" slider till you will bring the \"grid\" back to the screen. it is possible that you will have to go to negative \nvalues as well.\n\n---------------------------------------------------\nStep 3\n\nthis will create an axis in exact 3D position you found\nplease adjust (if needed)\nrotation of the card to match exact perspective you want\n\nTipp :\nadjusting \"scale\" and \"u_scale\":\nbe carefull when scaling up the card!!! from the moment one of the corners of the \"grid\" is passing the origin of the Camera the calculation will fail. So as a good practice leave your \"grid\" not too big it will not matter for final calculation since it still will lay on the same plane.\n\n\n---------------------------------------------------\nStep 4\n\nButton \"Go\"  will create for you few nodes\n\n1. CProject - basically it is a cornerPin node with steroids it allowes to you very easy set Reference point for your \"projection\", stabilize, crop. all in one\n2. CornerPin with a transformation baked in the \"matrix\" knob - usually i am using it to copy to GridWarp or SplineWarp\n3. Roto - the node i am using the most.\nthe transformation is baked into the root matrix.\nso just pick the frame create the rotoshape and enjoy!\n"}
 addUserKnob {26 credits l "" +STARTLINE T "CardToTrack  v1.0  ||  by Alexey Kuchinski  |  lamakaha@gmail.com  |  11/2016"}
}
 Input {
  inputs 0
  name Extra
  xpos -1449
  ypos -791
  number 2
 }
 Dot {
  name Dot11
  xpos -1415
  ypos 566
 }
set N6ade1a10 [stack 0]
 Dot {
  name Dot13
  xpos -1415
  ypos 644
 }
set N6acbc790 [stack 0]
 Dot {
  name Dot12
  xpos -1415
  ypos 688
 }
set N6abed970 [stack 0]
 Dot {
  name Dot9
  xpos -1415
  ypos 1731
 }
 Input {
  inputs 0
  name Camera
  xpos -624
  ypos 760
  number 1
 }
set N6b5827f0 [stack 0]
push $N6ade1a10
 Axis {
  inputs 0
  translate {{parent.input1.translate x1112 -519.8007202} {parent.input1.translate x1112 197.4966736} {parent.input1.translate x1112 -128.6857147}}
  rotate {{parent.input1.rotate} {parent.input1.rotate} {parent.input1.rotate}}
  name Axis1
  xpos -845
  ypos 44
 }
 ColorBars {
  inputs 0
  name ColorBars1
  xpos -976
  ypos -130
 }
 Card2 {
  rows 4
  columns 4
  z 10
  lens_in_focal {{parent.input1.focal}}
  lens_in_haperture {{parent.input1.haperture}}
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
  name Card2
  xpos -976
  ypos 8
  addUserKnob {20 User}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
 }
 TransformGeo {
  inputs 2
  name TransformGeo2
  xpos -976
  ypos 64
 }
 Switch {
  inputs 2
  which {{parent.extraHelper==1?1:0}}
  name GeoInput
  xpos -973
  ypos 562
 }
 Input {
  inputs 0
  name BG
  xpos 800
  ypos -858
 }
 Dot {
  name Dot4
  xpos 834
  ypos -788
 }
set N6b5ab890 [stack 0]
 Dot {
  name Dot5
  xpos -1122
  ypos -788
 }
 Dot {
  name Dot6
  xpos -1119
  ypos 911
 }
 ScanlineRender {
  inputs 3
  motion_vectors_type distance
  output_shader_vectors true
  P_channel rgb
  name ScanlineRender2
  xpos -973
  ypos 907
 }
 Switch {
  inputs 2
  which {{parent.extraHelper==2?1:0}}
  name WpasRender
  xpos -976
  ypos 1727
 }
 NoOp {
  name NoOp1
  tile_color 0xffff
  gl_color 0xffff
  xpos -976
  ypos 2323
  addUserKnob {20 User}
  addUserKnob {22 pick T "a=nuke.toNode(\"NoOp1\")\nr=nuke.sample(a,\"red\",a\['picker'].value(0),a\['picker'].value(1),1,1)\ng=nuke.sample(a,\"green\",a\['picker'].value(0),a\['picker'].value(1),1,1)\nb=nuke.sample(a,\"blue\",a\['picker'].value(0),a\['picker'].value(1),1,1)\n#nuke.tprint(r)\nnuke.toNode('look_at_Axis')\['translate'].setValue(\[r,g,b])" +STARTLINE}
  addUserKnob {12 picker}
  picker {674.7999878 751.7999878}
 }
 Clamp {
  channels rgba
  name Clamp1
  xpos -125
  ypos 2323
 }
push $N6b5827f0
 FrameHold {
  first_frame 1011
  name StabFrameHold
  selected true
  xpos -624
  ypos 1121
  disable true
 }
set N6acb0530 [stack 0]
push $N6b5827f0
 Axis {
  name Axis3
  xpos -500
  ypos 818
 }
 Dot {
  name Dot10
  xpos -476
  ypos 900
 }
 Card2 {
  inputs 0
  display wireframe
  render_mode off
  image_aspect false
  rows 1
  columns 1
  uniform_scale 600
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
  name Card3
  tile_color 0xff00ff
  gl_color 0xff00ff
  xpos -375
  ypos 822
  addUserKnob {20 User}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
 }
 TransformGeo {
  inputs 2
  name TransformGeo3
  tile_color 0xff00ff
  gl_color 0xff00ff
  xpos -375
  ypos 896
 }
 Dot {
  name Dot20
  xpos -341
  ypos 983
 }
 Wireframe {
  inputs 0
  operation "see through"
  line_width 2
  name Wireframe1
  xpos -702
  ypos 581
 }
set N6b6c4a50 [stack 0]
push $N6abed970
 ApplyMaterial {
  inputs 2
  name ApplyMaterial2
  xpos -660
  ypos 677
 }
push $N6b6c4a50
push $N6acbc790
 ApplyMaterial {
  inputs 2
  name ApplyMaterial1
  xpos -758
  ypos 640
 }
push 0
 Switch {
  inputs 2
  which {{parent.extraHelper==1?1:0}}
  name GeoInput1
  xpos -475
  ypos 640
 }
 Axis {
  inputs 0
  uniform_scale 10
  name Perspective
  xpos -624
  ypos 71
 }
 Axis {
  inputs 0
  translate {-84.78507996 62.40576172 -48.37187576}
  rotate {{degrees(atan((parent.input1.translate.y(ref)-translate.y)/sqrt(pow2(sqrt(pow2(parent.input1.translate.x(ref)-translate.x)+pow2(parent.input1.translate.z(ref)-translate.z))))))} {"parent.input1.translate.x(ref)-translate.x >= 0 ? 270-degrees(atan((parent.input1.translate.z(ref)-translate.z)/(parent.input1.translate.x(ref)-translate.x))): -degrees(atan((parent.input1.translate.z(ref)-translate.z)/(parent.input1.translate.x(ref)-translate.x)))-270"} {curve}}
  name look_at_Axis
  xpos -497
  ypos -59
  addUserKnob {20 User}
  addUserKnob {3 ref}
  ref {{parent.refFrame}}
 }
 Axis {
  display solid+wireframe
  translate {0 0 {parent.Zfind}}
  uniform_scale {{parent.Perspective.uniform_scale}}
  name Z_finder
  xpos -497
  ypos 23
 }
 Switch {
  inputs 2
  name Switch
  label "\[value which]"
  xpos -507
  ypos 155
 }
 Dot {
  name Dot1
  xpos -473
  ypos 222
 }
set Nbcb14280 [stack 0]
 Constant {
  inputs 0
  format "512 512 0 0 512 512 1 square_512"
  name Constant2
  tile_color 0xff
  xpos -227
  ypos -635
  postage_stamp false
 }
set Nbcb18c40 [stack 0]
 Wireframe {
  operation "see through"
  line_width 1
  line_color {1 0 0 1}
  name Wireframe4
  xpos -642
  ypos -416
 }
set N3a874c90 [stack 0]
 Card2 {
  display wireframe
  image_aspect false
  rows 1
  columns 1
  translate {0.5 -0.5 0}
  uniform_scale 0.03
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
  name Card9
  xpos -891
  ypos -369
  addUserKnob {20 User}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
 }
 Dot {
  name Dot19
  xpos -857
  ypos -260
 }
push $N3a874c90
 Card2 {
  display wireframe
  image_aspect false
  rows 1
  columns 1
  translate {0.5 0.5 0}
  uniform_scale 0.03
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
  name Card8
  xpos -806
  ypos -367
  addUserKnob {20 User}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
 }
 Dot {
  name Dot18
  xpos -772
  ypos -286
 }
push $N3a874c90
 Card2 {
  display wireframe
  image_aspect false
  rows 1
  columns 1
  translate {-0.5 -0.5 0}
  uniform_scale 0.03
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
  name Card7
  xpos -724
  ypos -367
  addUserKnob {20 User}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
 }
 Dot {
  name Dot17
  xpos -690
  ypos -312
 }
push $N3a874c90
 Card2 {
  display wireframe
  image_aspect false
  rows 1
  columns 1
  translate {-0.5 0.5 0}
  uniform_scale 0.03
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
  name Card6
  xpos -642
  ypos -373
  addUserKnob {20 User}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
 }
 MergeGeo {
  inputs 2
  selectable false
  name MergeGeo5
  xpos -642
  ypos -316
 }
 MergeGeo {
  inputs 2
  selectable false
  name MergeGeo6
  xpos -642
  ypos -290
 }
 MergeGeo {
  inputs 2
  selectable false
  name MergeGeo7
  xpos -642
  ypos -264
 }
 Dot {
  name Dot16
  xpos -608
  ypos -187
 }
push $Nbcb18c40
 Wireframe {
  operation "see through"
  line_width 1
  line_color {0 1 0 1}
  name Wireframe5
  xpos -495
  ypos -441
 }
 Card2 {
  display wireframe
  cast_shadow false
  receive_shadow false
  image_aspect false
  rows 2
  columns 2
  uniform_scale 100
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
  name Card5
  xpos -495
  ypos -371
  addUserKnob {20 User}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
 }
 Dot {
  name Dot15
  xpos -461
  ypos -307
 }
push $Nbcb18c40
 Wireframe {
  operation "see through"
  line_width 1
  line_color {1 0 1 1}
  name Wireframe3
  xpos -352
  ypos -421
 }
 Card2 {
  display wireframe
  rows 2
  columns 2
  translate {0 0 -0.0001}
  uniform_scale 0.1
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
  name Card4
  xpos -352
  ypos -377
  addUserKnob {20 User}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
 }
 Dot {
  name Dot14
  xpos -318
  ypos -333
 }
push $Nbcb18c40
 Wireframe {
  operation "see through"
  line_width 0.1
  name Wireframe2
  xpos -232
  ypos -427
 }
 Card2 {
  display wireframe
  rows 4
  columns 4
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
  name Card1
  xpos -232
  ypos -371
  addUserKnob {20 User}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
 }
 MergeGeo {
  inputs 2
  selectable false
  name MergeGeo2
  xpos -232
  ypos -337
 }
 MergeGeo {
  inputs 2
  selectable false
  name MergeGeo3
  xpos -232
  ypos -311
 }
 MergeGeo {
  inputs 2
  selectable false
  name MergeGeo4
  xpos -232
  ypos -191
 }
push 0
 Switch {
  inputs 2
  which 1
  name Switch1
  label "\[value which]"
  xpos -232
  ypos 167
 }
 TransformGeo {
  inputs 2
  name TransformGeo1
  xpos -232
  ypos 218
 }
 MergeGeo {
  inputs 2
  selectable false
  name MergeGeo1
  xpos -232
  ypos 640
 }
 Switch {
  inputs 2
  which {{parent.extraHelper==3?1:0}}
  name AnimCard
  xpos -232
  ypos 677
 }
 MergeGeo {
  inputs 2
  selectable false
  name MergeGeo8
  xpos -231
  ypos 979
 }
push $N6acb0530
push $Nbcb14280
 Dot {
  name Dot8
  xpos -470
  ypos 583
 }
push $N6b5827f0
push $N6b5ab890
 Dot {
  name Dot21
  xpos 834
  ypos 764
 }
set N84a4cbc0 [stack 0]
 Project3D {
  inputs 2
  crop false
  name Project3D1
  xpos 550
  ypos 760
 }
 Card2 {
  display wireframe
  rows 4
  columns 4
  uniform_scale 100000
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
  name Card10
  xpos 554
  ypos 950
  addUserKnob {20 User}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
  addUserKnob {22 "floor Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[0,0.5,0])\nn\['pivot'].setValue(\[0,-0.5,0])"}
  addUserKnob {22 "corner Pivot" -STARTLINE T "n=nuke.thisNode()\nn\['translate'].setValue(\[-.5,.5,0])\nn\['pivot'].setValue(\[.5,-.5,0])"}
  addUserKnob {22 snapToSelected -STARTLINE T "b=nuke.selectedNode()\['translate'].value()\nn=nuke.thisNode()\nn\['translate'].setValue(b)"}
 }
 TransformGeo {
  inputs 2
  name TransformGeo4
  xpos 554
  ypos 993
 }
push $N84a4cbc0
 Dot {
  name Dot22
  xpos 834
  ypos 1035
 }
set N14f87840 [stack 0]
 Remove {
  name Remove2
  xpos 653
  ypos 1025
 }
 ScanlineRender {
  inputs 3
  shutter 0
  motion_vectors_type distance
  name ScanlineRender3
  xpos 554
  ypos 1127
 }
set N14f94600 [stack 0]
push $N14f87840
 Switch {
  inputs 2
  which 1
  name StabSwitch
  label "\[value which]"
  xpos 800
  ypos 1121
  disable true
 }
 Dot {
  name Dot2
  xpos 834
  ypos 1510
 }
 Dot {
  name Dot3
  xpos 834
  ypos 1582
 }
set N137f0820 [stack 0]
 Remove {
  name Remove1
  xpos 154
  ypos 1578
 }
 ScanlineRender {
  inputs 3
  shutter 0
  motion_vectors_type distance
  name ScanlineRender1
  xpos -235
  ypos 1584
 }
 HueShift {
  name HueShift1
  xpos -235
  ypos 1702
 }
 Multiply {
  channels rgba
  value {{parent.op}}
  name Multiply1
  xpos -235
  ypos 1728
 }
push $N137f0820
 Merge2 {
  inputs 2
  name Merge2
  xpos 113
  ypos 1809
 }
 Dot {
  name Dot7
  xpos 147
  ypos 1882
 }
 Merge2 {
  inputs 2
  mix 0.001
  name Merge1
  xpos 113
  ypos 2323
 }
 Output {
  name Output1
  xpos 113
  ypos 2523
 }
 Axis {
  inputs 0
  translate {3994.217285 1141.840637 1395.124756}
  name Axis2
  xpos -730
  ypos 69
 }
push $N14f94600
 Viewer {
  frame 1009
  frame_range 1007-1290
  gain 8.6
  viewerProcess "None (default)"
  input_process false
  name Viewer1
  xpos 840
  ypos -10
  hide_input true
 }
end_group
